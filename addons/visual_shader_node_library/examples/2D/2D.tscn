[gd_scene load_steps=109 format=2]

[ext_resource path="res://addons/visual_shader_node_library/examples/2D/icon.png" type="Texture" id=1]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_3d.gd" type="Script" id=2]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/rotation_2d.gd" type="Script" id=3]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_4d.gd" type="Script" id=4]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_3d.gd" type="Script" id=5]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/perlin_2d.gd" type="Script" id=6]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/random.gd" type="Script" id=7]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_2d.gd" type="Script" id=8]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_2d_2x2.gd" type="Script" id=9]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_3d.gd" type="Script" id=10]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/cellular_3d_2x2x2.gd" type="Script" id=11]

[sub_resource type="VisualShaderNodeCustom" id=1]
script = ExtResource( 3 )

[sub_resource type="VisualShaderNodeInput" id=2]
input_name = "vertex"

[sub_resource type="VisualShaderNodeInput" id=3]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarConstant" id=4]
constant = 45.0

[sub_resource type="VisualShaderNodeScalarFunc" id=5]
function = 27

[sub_resource type="VisualShader" id=6]
code = "shader_type canvas_item;


// Rotation2D

void rotation_2d(float angle, vec3 pivot, in vec3 position_in,  out vec3 position_out) {
	mat2 rotation_matrix = mat2( vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle)));
	position_in -= pivot;
	position_out.xy = rotation_matrix * position_in.xy;
	position_out.z = position_in.z;
	position_out += pivot;
	
}

void vertex() {
// Input:4
	float n_out4p0 = TIME;

// Input:3
	vec3 n_out3p0 = vec3(VERTEX, 0.0);

// Rotation2D:2
	vec3 n_out2p0;
	{
		rotation_2d(n_out4p0, vec3(0.0, 0.0, 0.0), n_out3p0, n_out2p0);
	}

// Output:0
	VERTEX = n_out2p0.xy;

}

void fragment() {
// Output:0

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -606, -85 )
mode = 1
flags/light_only = false
nodes/vertex/0/position = Vector2( 260, 140 )
nodes/vertex/2/node = SubResource( 1 )
nodes/vertex/2/position = Vector2( 20, 140 )
nodes/vertex/3/node = SubResource( 2 )
nodes/vertex/3/position = Vector2( -200, 240 )
nodes/vertex/4/node = SubResource( 3 )
nodes/vertex/4/position = Vector2( -200, 60 )
nodes/vertex/5/node = SubResource( 4 )
nodes/vertex/5/position = Vector2( -420, 160 )
nodes/vertex/6/node = SubResource( 5 )
nodes/vertex/6/position = Vector2( -220, 160 )
nodes/vertex/connections = PoolIntArray( 3, 0, 2, 2, 2, 0, 0, 0, 5, 0, 6, 0, 4, 0, 2, 0 )

[sub_resource type="ShaderMaterial" id=7]
shader = SubResource( 6 )

[sub_resource type="VisualShaderNodeCustom" id=8]
default_input_values = [ 1, 0.0 ]
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeVec3Constant" id=9]
constant = Vector3( 1, 1, 1 )

[sub_resource type="VisualShaderNodeGlobalExpression" id=10]
size = Vector2( 464, 132 )
expression = "/*Rotation3D can also be used in Canvas Item*/

"

[sub_resource type="VisualShader" id=11]
code = "shader_type canvas_item;


// Rotation3D

mat4 rotation_matrix_3d(vec3 axis, float angle){
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(vec4(oc * axis.x * axis.x + c,			oc * axis.x * axis.y - axis.z * s,	oc * axis.z * axis.x + axis.y * s,	0.0),
                vec4(oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,			oc * axis.y * axis.z - axis.x * s,	0.0),
                vec4(oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, 	oc * axis.z * axis.z + c,			0.0),
                vec4(0.0,								0.0, 								0.0,								1.0));
}

void rotation_3d_normal(vec3 axis, float angle, in vec3 normal_in, out vec3 normal_out) {
	normal_out = (rotation_matrix_3d(axis, angle) * vec4(normal_in, 0.0)).xyz;
}

void rotation_3d(vec3 axis, float angle, vec3 pivot, in vec3 position_in, out vec3 position_out) {
	position_in.xyz -= pivot;
	vec4 position = vec4(position_in, 1.0);
	position_out = (rotation_matrix_3d(axis, angle) * position).xyz;
	position_out += pivot;
}
// GlobalExpression:0
	/*Rotation3D can also be used in Canvas Item*/
	
	

void vertex() {
// Vector:8
	vec3 n_out8p0 = vec3(1.000000, 1.000000, 1.000000);

// Input:4
	float n_out4p0 = TIME;

// Input:3
	vec3 n_out3p0 = vec3(VERTEX, 0.0);

// Rotation3D:7
	vec3 n_out7p0;
	vec3 n_out7p1;
	{
		rotation_3d(n_out8p0, n_out4p0, vec3(0.0, 0.0, 0.0), n_out3p0, n_out7p0);n_out7p1 = vec3(0.0, 0.0, 0.0);
	}

// Output:0
	VERTEX = n_out7p0.xy;

}

void fragment() {
// Output:0

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -519, -103 )
mode = 1
flags/light_only = false
nodes/vertex/0/position = Vector2( 260, 140 )
nodes/vertex/3/node = SubResource( 2 )
nodes/vertex/3/position = Vector2( -200, 240 )
nodes/vertex/4/node = SubResource( 3 )
nodes/vertex/4/position = Vector2( -200, 100 )
nodes/vertex/5/node = SubResource( 4 )
nodes/vertex/5/position = Vector2( -420, 160 )
nodes/vertex/6/node = SubResource( 5 )
nodes/vertex/6/position = Vector2( -220, 160 )
nodes/vertex/7/node = SubResource( 8 )
nodes/vertex/7/position = Vector2( 40, 140 )
nodes/vertex/8/node = SubResource( 9 )
nodes/vertex/8/position = Vector2( -340, 0 )
nodes/vertex/9/node = SubResource( 10 )
nodes/vertex/9/position = Vector2( 20, -40 )
nodes/vertex/9/size = Vector2( 464, 132 )
nodes/vertex/9/input_ports = ""
nodes/vertex/9/output_ports = ""
nodes/vertex/9/expression = "/*Rotation3D can also be used in Canvas Item*/

"
nodes/vertex/connections = PoolIntArray( 5, 0, 6, 0, 7, 0, 0, 0, 3, 0, 7, 3, 4, 0, 7, 1, 8, 0, 7, 0 )

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )

[sub_resource type="VisualShaderNodeInput" id=13]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarConstant" id=14]
constant = 10.0

[sub_resource type="VisualShaderNodeCustom" id=15]
script = ExtResource( 6 )

[sub_resource type="VisualShader" id=16]
code = "shader_type canvas_item;


// PerlinNoise2D


// GLSL textureless classic 2D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289(((x * 34.0) + 1.0) * x);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 fade(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_2d_np(vec2 P) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;
    
    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_2d_p(vec2 P, vec2 rep) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod(Pi, vec4(rep, rep)); // To create noise with explicit period
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;
    
    vec4 i = permute(permute(ix) + iy);
    
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;
    
    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Scalar:5
	float n_out5p0 = 10.000000;

// PerlinNoise2D:6
	float n_out6p0;
	{
		n_out6p0 = perlin_noise_2d_np(((n_out3p0).xy).xy * (vec3(n_out5p0)).xy.xy);
	}

// Output:0
	COLOR.rgb = vec3(n_out6p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -477.933, 7 )
mode = 1
flags/light_only = false
nodes/fragment/3/node = SubResource( 13 )
nodes/fragment/3/position = Vector2( -120, 140 )
nodes/fragment/5/node = SubResource( 14 )
nodes/fragment/5/position = Vector2( -120, 300 )
nodes/fragment/6/node = SubResource( 15 )
nodes/fragment/6/position = Vector2( 140, 140 )
nodes/fragment/connections = PoolIntArray( 6, 0, 0, 0, 3, 0, 6, 0, 5, 0, 6, 2 )

[sub_resource type="ShaderMaterial" id=17]
shader = SubResource( 16 )

[sub_resource type="VisualShaderNodeCustom" id=18]
script = ExtResource( 6 )

[sub_resource type="VisualShaderNodeInput" id=19]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarConstant" id=20]
constant = 10.0

[sub_resource type="VisualShaderNodeVec3Constant" id=21]
constant = Vector3( 5, 2, 0 )

[sub_resource type="VisualShader" id=22]
code = "shader_type canvas_item;


// PerlinNoise2D


// GLSL textureless classic 2D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289(((x * 34.0) + 1.0) * x);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec2 fade(vec2 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_2d_np(vec2 P) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;
    
    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_2d_p(vec2 P, vec2 rep) {
    vec4 Pi = floor(vec4(P, P)) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(vec4(P, P)) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod(Pi, vec4(rep, rep)); // To create noise with explicit period
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;
    
    vec4 i = permute(permute(ix) + iy);
    
    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;
    
    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);
    
    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));
    
    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 1.15 * n_xy + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Vector:5
	vec3 n_out5p0 = vec3(5.000000, 2.000000, 0.000000);

// Scalar:4
	float n_out4p0 = 10.000000;

// PerlinNoise2D:2
	float n_out2p0;
	{
		n_out2p0 = perlin_noise_2d_p(((n_out3p0).xy).xy * (vec3(n_out4p0)).xy.xy, (n_out5p0).xy);
	}

// Output:0
	COLOR.rgb = vec3(n_out2p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -477.933, 7 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 260, 120 )
nodes/fragment/2/node = SubResource( 18 )
nodes/fragment/2/position = Vector2( -20, 140 )
nodes/fragment/3/node = SubResource( 19 )
nodes/fragment/3/position = Vector2( -340, 80 )
nodes/fragment/4/node = SubResource( 20 )
nodes/fragment/4/position = Vector2( -380, 160 )
nodes/fragment/5/node = SubResource( 21 )
nodes/fragment/5/position = Vector2( -460, 240 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 0, 3, 0, 2, 0, 4, 0, 2, 2, 5, 0, 2, 1 )

[sub_resource type="ShaderMaterial" id=23]
shader = SubResource( 22 )

[sub_resource type="VisualShaderNodeVec3Constant" id=24]
constant = Vector3( 12, 12, 3 )

[sub_resource type="VisualShaderNodeVec3Constant" id=25]
constant = Vector3( 5, 5, 1 )

[sub_resource type="VisualShaderNodeCustom" id=26]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeCustom" id=27]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeVectorCompose" id=28]

[sub_resource type="VisualShaderNodeInput" id=29]
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorCompose" id=30]

[sub_resource type="VisualShaderNodeVectorDecompose" id=31]

[sub_resource type="VisualShaderNodeInput" id=32]
input_name = "time"

[sub_resource type="VisualShader" id=33]
code = "shader_type canvas_item;


// PerlinNoise3D

// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec3 mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289_4(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_3d_np(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_3d_p(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:7
	float n_out7p0 = n_out4p0.x;
	float n_out7p1 = n_out4p0.y;
	float n_out7p2 = n_out4p0.z;

// Input:8
	float n_out8p0 = TIME;

// VectorCompose:6
	vec3 n_out6p0 = vec3(n_out7p0, n_out7p1, n_out8p0);

// Vector:17
	vec3 n_out17p0 = vec3(5.000000, 5.000000, 1.000000);

// PerlinNoise3D:18
	float n_out18p0;
	{
		n_out18p0 = perlin_noise_3d_np(n_out6p0 * n_out17p0);
	}

// Vector:16
	vec3 n_out16p0 = vec3(12.000000, 12.000000, 3.000000);

// PerlinNoise3D:19
	float n_out19p0;
	{
		n_out19p0 = perlin_noise_3d_np(n_out6p0 * n_out16p0);
	}

// VectorCompose:3
	float n_in3p1 = 0.00000;
	vec3 n_out3p0 = vec3(n_out18p0, n_in3p1, n_out19p0);

// Output:0
	COLOR.rgb = n_out3p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -477.933, 7 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 580, 100 )
nodes/fragment/3/node = SubResource( 28 )
nodes/fragment/3/position = Vector2( 360, 100 )
nodes/fragment/4/node = SubResource( 29 )
nodes/fragment/4/position = Vector2( -560, 80 )
nodes/fragment/6/node = SubResource( 30 )
nodes/fragment/6/position = Vector2( -160, 80 )
nodes/fragment/7/node = SubResource( 31 )
nodes/fragment/7/position = Vector2( -380, 80 )
nodes/fragment/8/node = SubResource( 32 )
nodes/fragment/8/position = Vector2( -380, 220 )
nodes/fragment/16/node = SubResource( 24 )
nodes/fragment/16/position = Vector2( -300, 300 )
nodes/fragment/17/node = SubResource( 25 )
nodes/fragment/17/position = Vector2( -300, -60 )
nodes/fragment/18/node = SubResource( 26 )
nodes/fragment/18/position = Vector2( 140, 40 )
nodes/fragment/19/node = SubResource( 27 )
nodes/fragment/19/position = Vector2( 140, 180 )
nodes/fragment/connections = PoolIntArray( 3, 0, 0, 0, 7, 0, 6, 0, 7, 1, 6, 1, 8, 0, 6, 2, 4, 0, 7, 0, 18, 0, 3, 0, 6, 0, 18, 0, 17, 0, 18, 2, 19, 0, 3, 2, 16, 0, 19, 2, 6, 0, 19, 0 )

[sub_resource type="ShaderMaterial" id=34]
shader = SubResource( 33 )

[sub_resource type="VisualShaderNodeCustom" id=35]
script = ExtResource( 5 )

[sub_resource type="VisualShaderNodeVec3Constant" id=36]
constant = Vector3( 2, 2, 5 )

[sub_resource type="VisualShaderNodeScalarConstant" id=37]
constant = 10.0

[sub_resource type="VisualShaderNodeVectorCompose" id=38]

[sub_resource type="VisualShaderNodeVectorDecompose" id=39]

[sub_resource type="VisualShaderNodeInput" id=40]
input_name = "time"

[sub_resource type="VisualShaderNodeInput" id=41]
input_name = "uv"

[sub_resource type="VisualShader" id=42]
code = "shader_type canvas_item;


// PerlinNoise3D

// GLSL textureless classic 3D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-10-11
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise
//

vec3 mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289_4(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec3 fade(vec3 t) {
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_3d_np(vec3 P) {
    vec3 Pi0 = floor(P); // Integer part for indexing
    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}

// Classic Perlin noise, periodic variant
float perlin_noise_3d_p(vec3 P, vec3 rep) {
    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
    Pi0 = mod289_3(Pi0);
    Pi1 = mod289_3(Pi1);
    vec3 Pf0 = fract(P); // Fractional part for interpolation
    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.z);
    vec4 iz1 = vec4(Pi1.z);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    
    vec4 gx0 = ixy0 * (1.0 / 7.0);
    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
    gx0 = fract(gx0);
    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
    vec4 sz0 = step(gz0, vec4(0.0));
    gx0 -= sz0 * (step(0.0, gx0) - 0.5);
    gy0 -= sz0 * (step(0.0, gy0) - 0.5);
    
    vec4 gx1 = ixy1 * (1.0 / 7.0);
    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
    gx1 = fract(gx1);
    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
    vec4 sz1 = step(gz1, vec4(0.0));
    gx1 -= sz1 * (step(0.0, gx1) - 0.5);
    gy1 -= sz1 * (step(0.0, gy1) - 0.5);
    
    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
    
    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;
    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;
    
    float n000 = dot(g000, Pf0);
    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
    float n111 = dot(g111, Pf1);
    
    vec3 fade_xyz = fade(Pf0);
    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
    return 1.1 * n_xyz + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:8
	vec3 n_out8p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out8p0.x;
	float n_out6p1 = n_out8p0.y;
	float n_out6p2 = n_out8p0.z;

// Input:7
	float n_out7p0 = TIME;

// VectorCompose:5
	vec3 n_out5p0 = vec3(n_out6p0, n_out6p1, n_out7p0);

// Vector:3
	vec3 n_out3p0 = vec3(2.000000, 2.000000, 5.000000);

// Scalar:4
	float n_out4p0 = 10.000000;

// PerlinNoise3D:2
	float n_out2p0;
	{
		n_out2p0 = perlin_noise_3d_p(n_out5p0 * vec3(n_out4p0), n_out3p0);
	}

// Output:0
	COLOR.rgb = vec3(n_out2p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -549.933, 24 )
mode = 1
flags/light_only = false
nodes/fragment/2/node = SubResource( 35 )
nodes/fragment/2/position = Vector2( 100, 160 )
nodes/fragment/3/node = SubResource( 36 )
nodes/fragment/3/position = Vector2( -360, 180 )
nodes/fragment/4/node = SubResource( 37 )
nodes/fragment/4/position = Vector2( -274.933, 327 )
nodes/fragment/5/node = SubResource( 38 )
nodes/fragment/5/position = Vector2( -140, 20 )
nodes/fragment/6/node = SubResource( 39 )
nodes/fragment/6/position = Vector2( -380, -40 )
nodes/fragment/7/node = SubResource( 40 )
nodes/fragment/7/position = Vector2( -380, 100 )
nodes/fragment/8/node = SubResource( 41 )
nodes/fragment/8/position = Vector2( -600, -40 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 0, 3, 0, 2, 1, 4, 0, 2, 2, 5, 0, 2, 0, 6, 0, 5, 0, 6, 1, 5, 1, 7, 0, 5, 2, 8, 0, 6, 0 )

[sub_resource type="ShaderMaterial" id=43]
shader = SubResource( 42 )

[sub_resource type="VisualShaderNodeCustom" id=44]
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeInput" id=45]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarConstant" id=46]
constant = 10.0

[sub_resource type="VisualShaderNodeInput" id=47]
input_name = "screen_uv"

[sub_resource type="VisualShaderNodeVectorCompose" id=48]

[sub_resource type="VisualShaderNodeVectorDecompose" id=49]

[sub_resource type="VisualShaderNodeVectorDecompose" id=50]

[sub_resource type="VisualShader" id=51]
code = "shader_type canvas_item;


// PerlinNoise4D


// GLSL textureless classic 4D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise

vec4 mod289(vec4 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
	return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
	return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 fade(vec4 t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_4d_np(vec4 P) {
    vec4 Pi0 = floor(P); // Integer part for indexing
    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 ixy00 = permute(ixy0 + iw0);
    vec4 ixy01 = permute(ixy0 + iw1);
    vec4 ixy10 = permute(ixy1 + iw0);
    vec4 ixy11 = permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}

// Classic Perlin noise, periodic version
float perlin_noise_4d_p(vec4 P, vec4 rep) {
    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 ixy00 = permute(ixy0 + iw0);
    vec4 ixy01 = permute(ixy0 + iw1);
    vec4 ixy10 = permute(ixy1 + iw0);
    vec4 ixy11 = permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// Input:5
	vec3 n_out5p0 = vec3(SCREEN_UV, 0.0);

// VectorDecompose:8
	float n_out8p0 = n_out5p0.x;
	float n_out8p1 = n_out5p0.y;
	float n_out8p2 = n_out5p0.z;

// VectorCompose:6
	vec3 n_out6p0 = vec3(n_out7p0, n_out7p1, n_out8p0);

// Scalar:4
	float n_out4p0 = 10.000000;

// PerlinNoise4D:2
	float n_out2p0;
	{
		n_out2p0 = perlin_noise_4d_np(vec4(n_out6p0, n_out8p1) * vec4(vec3(n_out4p0), n_out4p0));
	}

// Output:0
	COLOR.rgb = vec3(n_out2p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -606, -85 )
mode = 1
flags/light_only = false
nodes/fragment/2/node = SubResource( 44 )
nodes/fragment/2/position = Vector2( 160, 140 )
nodes/fragment/3/node = SubResource( 45 )
nodes/fragment/3/position = Vector2( -520, 40 )
nodes/fragment/4/node = SubResource( 46 )
nodes/fragment/4/position = Vector2( -260, 340 )
nodes/fragment/5/node = SubResource( 47 )
nodes/fragment/5/position = Vector2( -580, 160 )
nodes/fragment/6/node = SubResource( 48 )
nodes/fragment/6/position = Vector2( -60, 60 )
nodes/fragment/7/node = SubResource( 49 )
nodes/fragment/7/position = Vector2( -340, 40 )
nodes/fragment/8/node = SubResource( 50 )
nodes/fragment/8/position = Vector2( -340, 160 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 0, 4, 0, 2, 4, 4, 0, 2, 5, 6, 0, 2, 0, 3, 0, 7, 0, 7, 0, 6, 0, 7, 1, 6, 1, 5, 0, 8, 0, 8, 0, 6, 2, 8, 1, 2, 1 )

[sub_resource type="ShaderMaterial" id=52]
shader = SubResource( 51 )

[sub_resource type="VisualShaderNodeCustom" id=53]
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeVectorDecompose" id=54]

[sub_resource type="VisualShaderNodeVectorDecompose" id=55]

[sub_resource type="VisualShaderNodeVectorCompose" id=56]

[sub_resource type="VisualShaderNodeScalarConstant" id=57]
constant = 2.0

[sub_resource type="VisualShaderNodeScalarConstant" id=58]
constant = 10.0

[sub_resource type="VisualShaderNodeInput" id=59]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=60]
input_name = "screen_uv"

[sub_resource type="VisualShader" id=61]
code = "shader_type canvas_item;


// PerlinNoise4D


// GLSL textureless classic 4D noise \\\"cnoise\\\",
// with an RSL-style periodic variant \\\"pnoise\\\".
// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
// Version: 2011-08-22
//
// Many thanks to Ian McEwan of Ashima Arts for the
// ideas for permutation and gradient selection.
//
// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
// Distributed under the MIT license. See LICENSE file.
// https://github.com/stegu/webgl-noise

vec4 mod289(vec4 x) {
	return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
	return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
	return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 fade(vec4 t) {
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float perlin_noise_4d_np(vec4 P) {
    vec4 Pi0 = floor(P); // Integer part for indexing
    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 ixy00 = permute(ixy0 + iw0);
    vec4 ixy01 = permute(ixy0 + iw1);
    vec4 ixy10 = permute(ixy1 + iw0);
    vec4 ixy11 = permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}

// Classic Perlin noise, periodic version
float perlin_noise_4d_p(vec4 P, vec4 rep) {
    vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep
    vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep
    Pi0 = mod289(Pi0);
    Pi1 = mod289(Pi1);
    vec4 Pf0 = fract(P); // Fractional part for interpolation
    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0
    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
    vec4 iy = vec4(Pi0.yy, Pi1.yy);
    vec4 iz0 = vec4(Pi0.zzzz);
    vec4 iz1 = vec4(Pi1.zzzz);
    vec4 iw0 = vec4(Pi0.wwww);
    vec4 iw1 = vec4(Pi1.wwww);
    
    vec4 ixy = permute(permute(ix) + iy);
    vec4 ixy0 = permute(ixy + iz0);
    vec4 ixy1 = permute(ixy + iz1);
    vec4 ixy00 = permute(ixy0 + iw0);
    vec4 ixy01 = permute(ixy0 + iw1);
    vec4 ixy10 = permute(ixy1 + iw0);
    vec4 ixy11 = permute(ixy1 + iw1);
    
    vec4 gx00 = ixy00 * (1.0 / 7.0);
    vec4 gy00 = floor(gx00) * (1.0 / 7.0);
    vec4 gz00 = floor(gy00) * (1.0 / 6.0);
    gx00 = fract(gx00) - 0.5;
    gy00 = fract(gy00) - 0.5;
    gz00 = fract(gz00) - 0.5;
    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
    vec4 sw00 = step(gw00, vec4(0.0));
    gx00 -= sw00 * (step(0.0, gx00) - 0.5);
    gy00 -= sw00 * (step(0.0, gy00) - 0.5);
    
    vec4 gx01 = ixy01 * (1.0 / 7.0);
    vec4 gy01 = floor(gx01) * (1.0 / 7.0);
    vec4 gz01 = floor(gy01) * (1.0 / 6.0);
    gx01 = fract(gx01) - 0.5;
    gy01 = fract(gy01) - 0.5;
    gz01 = fract(gz01) - 0.5;
    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
    vec4 sw01 = step(gw01, vec4(0.0));
    gx01 -= sw01 * (step(0.0, gx01) - 0.5);
    gy01 -= sw01 * (step(0.0, gy01) - 0.5);
    
    vec4 gx10 = ixy10 * (1.0 / 7.0);
    vec4 gy10 = floor(gx10) * (1.0 / 7.0);
    vec4 gz10 = floor(gy10) * (1.0 / 6.0);
    gx10 = fract(gx10) - 0.5;
    gy10 = fract(gy10) - 0.5;
    gz10 = fract(gz10) - 0.5;
    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
    vec4 sw10 = step(gw10, vec4(0.0));
    gx10 -= sw10 * (step(0.0, gx10) - 0.5);
    gy10 -= sw10 * (step(0.0, gy10) - 0.5);
    
    vec4 gx11 = ixy11 * (1.0 / 7.0);
    vec4 gy11 = floor(gx11) * (1.0 / 7.0);
    vec4 gz11 = floor(gy11) * (1.0 / 6.0);
    gx11 = fract(gx11) - 0.5;
    gy11 = fract(gy11) - 0.5;
    gz11 = fract(gz11) - 0.5;
    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
    vec4 sw11 = step(gw11, vec4(0.0));
    gx11 -= sw11 * (step(0.0, gx11) - 0.5);
    gy11 -= sw11 * (step(0.0, gy11) - 0.5);
    
    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);
    
    vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
    g0000 *= norm00.x;
    g0100 *= norm00.y;
    g1000 *= norm00.z;
    g1100 *= norm00.w;
    
    vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
    g0001 *= norm01.x;
    g0101 *= norm01.y;
    g1001 *= norm01.z;
    g1101 *= norm01.w;
    
    vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
    g0010 *= norm10.x;
    g0110 *= norm10.y;
    g1010 *= norm10.z;
    g1110 *= norm10.w;
    
    vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));
    g0011 *= norm11.x;
    g0111 *= norm11.y;
    g1011 *= norm11.z;
    g1111 *= norm11.w;
    
    float n0000 = dot(g0000, Pf0);
    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));
    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));
    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));
    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));
    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));
    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));
    float n1111 = dot(g1111, Pf1);
    
    vec4 fade_xyzw = fade(Pf0);
    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
    return 1.1 * n_xyzw + 0.5;
}


void vertex() {
// Output:0

}

void fragment() {
// Input:8
	vec3 n_out8p0 = vec3(UV, 0.0);

// VectorDecompose:3
	float n_out3p0 = n_out8p0.x;
	float n_out3p1 = n_out8p0.y;
	float n_out3p2 = n_out8p0.z;

// Input:9
	vec3 n_out9p0 = vec3(SCREEN_UV, 0.0);

// VectorDecompose:4
	float n_out4p0 = n_out9p0.x;
	float n_out4p1 = n_out9p0.y;
	float n_out4p2 = n_out9p0.z;

// VectorCompose:5
	vec3 n_out5p0 = vec3(n_out3p0, n_out3p1, n_out4p0);

// Scalar:6
	float n_out6p0 = 2.000000;

// Scalar:7
	float n_out7p0 = 10.000000;

// PerlinNoise4D:2
	float n_out2p0;
	{
		n_out2p0 = perlin_noise_4d_p(vec4(n_out5p0, n_out4p1) * vec4(vec3(n_out7p0), n_out7p0), vec4(vec3(n_out6p0), n_out6p0));
	}

// Output:0
	COLOR.rgb = vec3(n_out2p0);

}

void light() {
// Output:0

}
"
mode = 1
flags/light_only = false
nodes/fragment/2/node = SubResource( 53 )
nodes/fragment/2/position = Vector2( 80, 120 )
nodes/fragment/3/node = SubResource( 54 )
nodes/fragment/3/position = Vector2( -520, 60 )
nodes/fragment/4/node = SubResource( 55 )
nodes/fragment/4/position = Vector2( -520, 200 )
nodes/fragment/5/node = SubResource( 56 )
nodes/fragment/5/position = Vector2( -160, 60 )
nodes/fragment/6/node = SubResource( 57 )
nodes/fragment/6/position = Vector2( -220, 240 )
nodes/fragment/7/node = SubResource( 58 )
nodes/fragment/7/position = Vector2( -220, 300 )
nodes/fragment/8/node = SubResource( 59 )
nodes/fragment/8/position = Vector2( -720, 60 )
nodes/fragment/9/node = SubResource( 60 )
nodes/fragment/9/position = Vector2( -780, 200 )
nodes/fragment/connections = PoolIntArray( 2, 0, 0, 0, 3, 0, 5, 0, 3, 1, 5, 1, 4, 0, 5, 2, 4, 1, 2, 1, 5, 0, 2, 0, 6, 0, 2, 2, 6, 0, 2, 3, 7, 0, 2, 4, 7, 0, 2, 5, 8, 0, 3, 0, 9, 0, 4, 0 )

[sub_resource type="ShaderMaterial" id=62]
shader = SubResource( 61 )

[sub_resource type="VisualShaderNodeInput" id=63]
input_name = "uv"

[sub_resource type="VisualShaderNodeInput" id=64]
input_name = "time"

[sub_resource type="VisualShaderNodeCustom" id=65]
script = ExtResource( 7 )

[sub_resource type="VisualShaderNodeScalarInterp" id=66]

[sub_resource type="VisualShaderNodeVectorDecompose" id=67]

[sub_resource type="VisualShaderNodeScalarOp" id=68]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShader" id=69]
code = "shader_type canvas_item;


// RandomNoise

	float rand(vec4 co){
		float f = dot(fract(co),vec4(129.898,782.33,944.32214932,122.2834234542));
		return fract(sin(f) * 437588.5453);
	}
	

void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Input:4
	float n_out4p0 = TIME;

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// ScalarOp:8
	float n_in8p1 = 0.50000;
	float n_out8p0 = step(n_out7p0, n_in8p1);

// ScalarMix:6
	float n_in6p1 = 1.00000;
	float n_out6p0 = mix(n_out4p0, n_in6p1, n_out8p0);

// RandomNoise:5
	float n_out5p0;
	{
		n_out5p0 = rand(vec4(n_out3p0, n_out6p0));
	}

// Output:0
	COLOR.rgb = vec3(n_out5p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -649.333, 47 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 280, 120 )
nodes/fragment/3/node = SubResource( 63 )
nodes/fragment/3/position = Vector2( -1080, 120 )
nodes/fragment/4/node = SubResource( 64 )
nodes/fragment/4/position = Vector2( -320, 200 )
nodes/fragment/5/node = SubResource( 65 )
nodes/fragment/5/position = Vector2( 80, 120 )
nodes/fragment/6/node = SubResource( 66 )
nodes/fragment/6/position = Vector2( -120, 240 )
nodes/fragment/7/node = SubResource( 67 )
nodes/fragment/7/position = Vector2( -900, 220 )
nodes/fragment/8/node = SubResource( 68 )
nodes/fragment/8/position = Vector2( -620, 220 )
nodes/fragment/connections = PoolIntArray( 5, 0, 0, 0, 3, 0, 5, 0, 4, 0, 6, 0, 6, 0, 5, 1, 3, 0, 7, 0, 7, 0, 8, 0, 8, 0, 6, 2 )

[sub_resource type="ShaderMaterial" id=70]
shader = SubResource( 69 )

[sub_resource type="VisualShaderNodeInput" id=71]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarConstant" id=72]
constant = 10.0

[sub_resource type="VisualShaderNodeScalarConstant" id=73]
constant = 1.0

[sub_resource type="VisualShaderNodeCustom" id=74]
output_port_for_preview = 2
script = ExtResource( 8 )

[sub_resource type="VisualShaderNodeVectorDecompose" id=75]

[sub_resource type="VisualShaderNodeScalarOp" id=76]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeScalarInterp" id=77]
output_port_for_preview = 0

[sub_resource type="VisualShader" id=78]
code = "shader_type canvas_item;


// CellularNoise2D


// Cellular noise (\"Worley noise\") in 2D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289_2(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 mod7(vec3 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 permute(vec3 x) {
    return mod289_3((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Standard 3x3 search window for good F1 and F2 values
vec2 cellular_noise_2d(vec2 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 3/7

    vec2 Pi = mod289_2(floor(P));
    vec2 Pf = fract(P);
    vec3 oi = vec3(-1.0, 0.0, 1.0);
    vec3 of = vec3(-0.5, 0.5, 1.5);
    vec3 px = permute(Pi.x + oi);
    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
    vec3 ox = fract(p*K) - Ko;
    vec3 oy = mod7(floor(p*K))*K - Ko;
    vec3 dx = Pf.x + 0.5 + jitter*ox;
    vec3 dy = Pf.y - of + jitter*oy;
    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
    p = permute(px.y + Pi.y + oi); // p21, p22, p23
    ox = fract(p*K) - Ko;
    oy = mod7(floor(p*K))*K - Ko;
    dx = Pf.x - 0.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
    p = permute(px.z + Pi.y + oi); // p31, p32, p33
    ox = fract(p*K) - Ko;
    oy = mod7(floor(p*K))*K - Ko;
    dx = Pf.x - 1.5 + jitter*ox;
    dy = Pf.y - of + jitter*oy;
    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
    // Sort out the two smallest distances (F1, F2)
    vec3 d1a = min(d1, d2);
    d2 = max(d1, d2); // Swap to keep candidates for F2
    d2 = min(d2, d3); // neither F1 nor F2 are now in d3
    d1 = min(d1a, d2); // F1 is now in d1
    d2 = max(d1a, d2); // Swap to keep candidates for F2
    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz
    d1.y = min(d1.y, d1.z); // nor in  d1.z
    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.
    return sqrt(d1.xy);
}


void vertex() {
// Output:0

}

void fragment() {
// Input:3
	vec3 n_out3p0 = vec3(UV, 0.0);

// Scalar:4
	float n_out4p0 = 10.000000;

// Scalar:5
	float n_out5p0 = 1.000000;

// CellularNoise2D:6
	vec3 n_out6p0;
	float n_out6p1;
	float n_out6p2;
	{
		
			
			n_out6p0 = vec3(cellular_noise_2d((n_out3p0).xy * (vec3(n_out4p0)).xy, n_out5p0), 0.0);
			n_out6p1 = n_out6p0.x;n_out6p2 = n_out6p0.y;
			
	}

// VectorDecompose:7
	float n_out7p0 = n_out3p0.x;
	float n_out7p1 = n_out3p0.y;
	float n_out7p2 = n_out3p0.z;

// ScalarOp:8
	float n_in8p1 = 0.50000;
	float n_out8p0 = step(n_out7p0, n_in8p1);

// ScalarMix:9
	float n_out9p0 = mix(n_out6p2, n_out6p1, n_out8p0);

// Output:0
	COLOR.rgb = vec3(n_out9p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -212, -38.25 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 580, 120 )
nodes/fragment/3/node = SubResource( 71 )
nodes/fragment/3/position = Vector2( -280, 40 )
nodes/fragment/4/node = SubResource( 72 )
nodes/fragment/4/position = Vector2( -280, 120 )
nodes/fragment/5/node = SubResource( 73 )
nodes/fragment/5/position = Vector2( -280, 200 )
nodes/fragment/6/node = SubResource( 74 )
nodes/fragment/6/position = Vector2( 60, 120 )
nodes/fragment/7/node = SubResource( 75 )
nodes/fragment/7/position = Vector2( -120, -40 )
nodes/fragment/8/node = SubResource( 76 )
nodes/fragment/8/position = Vector2( 100, -40 )
nodes/fragment/9/node = SubResource( 77 )
nodes/fragment/9/position = Vector2( 360, 40 )
nodes/fragment/connections = PoolIntArray( 3, 0, 6, 0, 4, 0, 6, 1, 5, 0, 6, 2, 3, 0, 7, 0, 7, 0, 8, 0, 8, 0, 9, 2, 9, 0, 0, 0, 6, 1, 9, 1, 6, 2, 9, 0 )

[sub_resource type="ShaderMaterial" id=79]
shader = SubResource( 78 )

[sub_resource type="VisualShaderNodeScalarInterp" id=80]

[sub_resource type="VisualShaderNodeInput" id=81]
input_name = "uv"

[sub_resource type="VisualShaderNodeScalarConstant" id=82]
constant = 10.0

[sub_resource type="VisualShaderNodeVectorDecompose" id=83]

[sub_resource type="VisualShaderNodeScalarOp" id=84]
default_input_values = [ 0, 0.0, 1, 0.5 ]
operator = 9

[sub_resource type="VisualShaderNodeScalarConstant" id=85]
constant = 1.0

[sub_resource type="VisualShaderNodeCustom" id=86]
script = ExtResource( 9 )

[sub_resource type="VisualShader" id=87]
code = "shader_type canvas_item;


// CellularNoise2D_2X2


// Cellular noise (\\\"Worley noise\\\") in 2D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec2 mod289_2(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289_4(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec4 mod7(vec4 x) {
  return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec4 permute(vec4 x) {
  return mod289_4((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Speeded up by using 2x2 search window instead of 3x3,
// at the expense of some strong pattern artifacts.
// F2 is often wrong and has sharp discontinuities.
// If you need a smooth F2, use the slower 3x3 version.
// F1 is sometimes wrong, too, but OK for most purposes.
vec2 cellular_noise_2d_2x2(vec2 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float K2 = 0.0714285714285; // K/2

    vec2 Pi = mod289_2(floor(P));
    vec2 Pf = fract(P);
    vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);
    vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);
    vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));
    p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));
    vec4 ox = mod7(p)*K+K2;
    vec4 oy = mod7(floor(p*K))*K+K2;
    vec4 dx = Pfx + jitter*ox;
    vec4 dy = Pfy + jitter*oy;
    vec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared
    // Sort out the two smallest distances

/*// F1 Only Block (works faster of course)
    d.xy = min(d.xy, d.zw);
    d.x = min(d.x, d.y);
    return vec2(sqrt(d.x)); // F1 duplicated, F2 not computed
//*/// End of F1 Only Block

//*// F1 and F2 block
    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller
    d.xz = (d.x < d.z) ? d.xz : d.zx;
    d.xw = (d.x < d.w) ? d.xw : d.wx;
    d.y = min(d.y, d.z);
    d.y = min(d.y, d.w);
    return sqrt(d.xy);
//*/// End of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// Scalar:5
	float n_out5p0 = 10.000000;

// Scalar:8
	float n_out8p0 = 1.000000;

// CellularNoise2D_2X2:9
	vec3 n_out9p0;
	float n_out9p1;
	float n_out9p2;
	{
		
			
			n_out9p0 = vec3(cellular_noise_2d_2x2((n_out4p0).xy * (vec3(n_out5p0)).xy, n_out8p0), 0.0);
			n_out9p1 = n_out9p0.x;n_out9p2 = n_out9p0.y;
			
	}

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out9p2, n_out9p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -92, -40 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( 40, 0 )
nodes/fragment/5/node = SubResource( 82 )
nodes/fragment/5/position = Vector2( 40, 100 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 240, -40 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/8/node = SubResource( 85 )
nodes/fragment/8/position = Vector2( 40, 200 )
nodes/fragment/9/node = SubResource( 86 )
nodes/fragment/9/position = Vector2( 360, 100 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 4, 0, 9, 0, 5, 0, 9, 1, 8, 0, 9, 2, 9, 1, 3, 1, 9, 2, 3, 0, 3, 0, 0, 0 )

[sub_resource type="ShaderMaterial" id=88]
shader = SubResource( 87 )

[sub_resource type="VisualShaderNodeVectorCompose" id=89]

[sub_resource type="VisualShaderNodeCustom" id=90]
script = ExtResource( 10 )

[sub_resource type="VisualShaderNodeInput" id=91]
input_name = "time"

[sub_resource type="VisualShaderNodeScalarOp" id=92]
default_input_values = [ 0, 0.0, 1, 0.1 ]
operator = 2

[sub_resource type="VisualShader" id=93]
code = "shader_type canvas_item;


// CelluarNoise3D


// Cellular noise (\"Worley noise\") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec3 mod7(vec3 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 permute(vec3 x) {
    return mod289((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// 3x3x3 search region for good F2 everywhere, but a lot
// slower than the 2x2x2 version.
// The code below is a bit scary even to its author,
// but it has at least half decent performance on a
// modern GPU. In any case, it beats any software
// implementation of Worley noise hands down.

vec2 cellular_noise_3d(vec3 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 1/2-K/2
    float K2 = 0.020408163265306; // 1/(7*7)
    float Kz = 0.166666666667; // 1/6
    float Kzo = 0.416666666667; // 1/2-1/6*2
    
    vec3 Pi = mod289(floor(P));
    vec3 Pf = fract(P) - 0.5;
    
    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
    
    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));
    vec3 p1 = permute(p + Pi.y - 1.0);
    vec3 p2 = permute(p + Pi.y);
    vec3 p3 = permute(p + Pi.y + 1.0);
    
    vec3 p11 = permute(p1 + Pi.z - 1.0);
    vec3 p12 = permute(p1 + Pi.z);
    vec3 p13 = permute(p1 + Pi.z + 1.0);
    
    vec3 p21 = permute(p2 + Pi.z - 1.0);
    vec3 p22 = permute(p2 + Pi.z);
    vec3 p23 = permute(p2 + Pi.z + 1.0);
    
    vec3 p31 = permute(p3 + Pi.z - 1.0);
    vec3 p32 = permute(p3 + Pi.z);
    vec3 p33 = permute(p3 + Pi.z + 1.0);
    
    vec3 ox11 = fract(p11*K) - Ko;
    vec3 oy11 = mod7(floor(p11*K))*K - Ko;
    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed
    
    vec3 ox12 = fract(p12*K) - Ko;
    vec3 oy12 = mod7(floor(p12*K))*K - Ko;
    vec3 oz12 = floor(p12*K2)*Kz - Kzo;
    
    vec3 ox13 = fract(p13*K) - Ko;
    vec3 oy13 = mod7(floor(p13*K))*K - Ko;
    vec3 oz13 = floor(p13*K2)*Kz - Kzo;
    
    vec3 ox21 = fract(p21*K) - Ko;
    vec3 oy21 = mod7(floor(p21*K))*K - Ko;
    vec3 oz21 = floor(p21*K2)*Kz - Kzo;
    
    vec3 ox22 = fract(p22*K) - Ko;
    vec3 oy22 = mod7(floor(p22*K))*K - Ko;
    vec3 oz22 = floor(p22*K2)*Kz - Kzo;
    
    vec3 ox23 = fract(p23*K) - Ko;
    vec3 oy23 = mod7(floor(p23*K))*K - Ko;
    vec3 oz23 = floor(p23*K2)*Kz - Kzo;
    
    vec3 ox31 = fract(p31*K) - Ko;
    vec3 oy31 = mod7(floor(p31*K))*K - Ko;
    vec3 oz31 = floor(p31*K2)*Kz - Kzo;
    
    vec3 ox32 = fract(p32*K) - Ko;
    vec3 oy32 = mod7(floor(p32*K))*K - Ko;
    vec3 oz32 = floor(p32*K2)*Kz - Kzo;
    
    vec3 ox33 = fract(p33*K) - Ko;
    vec3 oy33 = mod7(floor(p33*K))*K - Ko;
    vec3 oz33 = floor(p33*K2)*Kz - Kzo;
    
    vec3 dx11 = Pfx + jitter*ox11;
    vec3 dy11 = Pfy.x + jitter*oy11;
    vec3 dz11 = Pfz.x + jitter*oz11;
    
    vec3 dx12 = Pfx + jitter*ox12;
    vec3 dy12 = Pfy.x + jitter*oy12;
    vec3 dz12 = Pfz.y + jitter*oz12;
    
    vec3 dx13 = Pfx + jitter*ox13;
    vec3 dy13 = Pfy.x + jitter*oy13;
    vec3 dz13 = Pfz.z + jitter*oz13;
    
    vec3 dx21 = Pfx + jitter*ox21;
    vec3 dy21 = Pfy.y + jitter*oy21;
    vec3 dz21 = Pfz.x + jitter*oz21;
    
    vec3 dx22 = Pfx + jitter*ox22;
    vec3 dy22 = Pfy.y + jitter*oy22;
    vec3 dz22 = Pfz.y + jitter*oz22;
    
    vec3 dx23 = Pfx + jitter*ox23;
    vec3 dy23 = Pfy.y + jitter*oy23;
    vec3 dz23 = Pfz.z + jitter*oz23;
    
    vec3 dx31 = Pfx + jitter*ox31;
    vec3 dy31 = Pfy.z + jitter*oy31;
    vec3 dz31 = Pfz.x + jitter*oz31;
    
    vec3 dx32 = Pfx + jitter*ox32;
    vec3 dy32 = Pfy.z + jitter*oy32;
    vec3 dz32 = Pfz.y + jitter*oz32;
    
    vec3 dx33 = Pfx + jitter*ox33;
    vec3 dy33 = Pfy.z + jitter*oy33;
    vec3 dz33 = Pfz.z + jitter*oz33;
    
    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;
    
    // Sort out the two smallest distances (F1, F2)
/*// F1 only block
    vec3 d1 = min(min(d11,d12), d13);
    vec3 d2 = min(min(d21,d22), d23);
    vec3 d3 = min(min(d31,d32), d33);
    vec3 d = min(min(d1,d2), d3);
    d.x = min(min(d.x,d.y),d.z);
    return vec2(sqrt(d.x)); // F1 duplicated, no F2 computed
//*/// End of F1 only block
//*// F1 and F2 block
    vec3 d1a = min(d11, d12);
    d12 = max(d11, d12);
    d11 = min(d1a, d13); // Smallest now not in d12 or d13
    d13 = max(d1a, d13);
    d12 = min(d12, d13); // 2nd smallest now not in d13
    vec3 d2a = min(d21, d22);
    d22 = max(d21, d22);
    d21 = min(d2a, d23); // Smallest now not in d22 or d23
    d23 = max(d2a, d23);
    d22 = min(d22, d23); // 2nd smallest now not in d23
    vec3 d3a = min(d31, d32);
    d32 = max(d31, d32);
    d31 = min(d3a, d33); // Smallest now not in d32 or d33
    d33 = max(d3a, d33);
    d32 = min(d32, d33); // 2nd smallest now not in d33
    vec3 da = min(d11, d21);
    d21 = max(d11, d21);
    d11 = min(da, d31); // Smallest now in d11
    d31 = max(da, d31); // 2nd smallest now not in d31
    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
    d12 = min(d12, d21); // 2nd smallest now not in d21
    d12 = min(d12, d22); // nor in d22
    d12 = min(d12, d31); // nor in d31
    d12 = min(d12, d32); // nor in d32
    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
    d11.y = min(d11.y,d12.z); // Only two more to go
    d11.y = min(d11.y,d11.z); // Done! (Phew!)
    return sqrt(d11.xy); // F1, F2
//*/// End of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// Input:12
	float n_out12p0 = TIME;

// ScalarOp:13
	float n_in13p1 = 0.10000;
	float n_out13p0 = n_out12p0 * n_in13p1;

// VectorCompose:10
	vec3 n_out10p0 = vec3(n_out6p0, n_out6p1, n_out13p0);

// Scalar:5
	float n_out5p0 = 10.000000;

// Scalar:8
	float n_out8p0 = 1.000000;

// CelluarNoise3D:11
	vec3 n_out11p0;
	float n_out11p1;
	float n_out11p2;
	{
		
			
			n_out11p0 = vec3(cellular_noise_3d(n_out10p0 * vec3(n_out5p0), n_out8p0), 0.0);
			n_out11p1 = n_out11p0.x;n_out11p2 = n_out11p0.y;
			
	}

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out11p2, n_out11p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -345, -75 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( -140, -20 )
nodes/fragment/5/node = SubResource( 82 )
nodes/fragment/5/position = Vector2( -160, 200 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 40, -60 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/8/node = SubResource( 85 )
nodes/fragment/8/position = Vector2( -160, 280 )
nodes/fragment/10/node = SubResource( 89 )
nodes/fragment/10/position = Vector2( 140, 80 )
nodes/fragment/11/node = SubResource( 90 )
nodes/fragment/11/position = Vector2( 400, 100 )
nodes/fragment/12/node = SubResource( 91 )
nodes/fragment/12/position = Vector2( -300, 80 )
nodes/fragment/13/node = SubResource( 92 )
nodes/fragment/13/position = Vector2( -80, 60 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 3, 0, 0, 0, 6, 0, 10, 0, 6, 1, 10, 1, 11, 1, 3, 1, 10, 0, 11, 0, 5, 0, 11, 1, 8, 0, 11, 2, 12, 0, 13, 0, 13, 0, 10, 2, 11, 2, 3, 0 )

[sub_resource type="ShaderMaterial" id=94]
shader = SubResource( 93 )

[sub_resource type="VisualShaderNodeCustom" id=98]
script = ExtResource( 11 )

[sub_resource type="VisualShader" id=96]
code = "shader_type canvas_item;


// CelluarNoise3D_2x2x2


// Cellular noise (\"Worley noise\") in 3D in GLSL.
// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
// This code is released under the conditions of the MIT license.
// See LICENSE file for details.
// https://github.com/stegu/webgl-noise

// Modulo 289 without a division (only multiplications)
vec3 mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

// Modulo 7 without a division
vec4 mod7(vec4 x) {
    return x - floor(x * (1.0 / 7.0)) * 7.0;
}

// Permutation polynomial: (34x^2 + x) mod 289
vec3 permute_3(vec3 x) {
    return mod289_3((34.0 * x + 1.0) * x);
}

vec4 permute_4(vec4 x) {
    return mod289_4((34.0 * x + 1.0) * x);
}

// Cellular noise, returning F1 and F2 in a vec2.
// Speeded up by using 2x2x2 search window instead of 3x3x3,
// at the expense of some pattern artifacts.
// F2 is often wrong and has sharp discontinuities.
// If you need a good F2, use the slower 3x3x3 version.
vec2 cellular_noise_3d_2x2x2(vec3 P, float jitter) {
    float K = 0.142857142857; // 1/7
    float Ko = 0.428571428571; // 1/2-K/2
    float K2 = 0.020408163265306; // 1/(7*7)
    float Kz = 0.166666666667; // 1/6
    float Kzo = 0.416666666667; // 1/2-1/6*2

    vec3 Pi = mod289_3(floor(P));
    vec3 Pf = fract(P);
    vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);
    vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);
    vec4 p = permute_4(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));
    p = permute_4(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));
    vec4 p1 = permute_4(p + Pi.z); // z+0
    vec4 p2 = permute_4(p + Pi.z + vec4(1.0)); // z+1
    vec4 ox1 = fract(p1*K) - Ko;
    vec4 oy1 = mod7(floor(p1*K))*K - Ko;
    vec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed
    vec4 ox2 = fract(p2*K) - Ko;
    vec4 oy2 = mod7(floor(p2*K))*K - Ko;
    vec4 oz2 = floor(p2*K2)*Kz - Kzo;
    vec4 dx1 = Pfx + jitter*ox1;
    vec4 dy1 = Pfy + jitter*oy1;
    vec4 dz1 = Pf.z + jitter*oz1;
    vec4 dx2 = Pfx + jitter*ox2;
    vec4 dy2 = Pfy + jitter*oy2;
    vec4 dz2 = Pf.z - 1.0 + jitter*oz2;
    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0
    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1

    // Sort out the two smallest distances (F1, F2)
/*// Block for F1 only
    d1 = min(d1, d2);
    d1.xy = min(d1.xy, d1.wz);
    d1.x = min(d1.x, d1.y);
    return vec2(sqrt(d1.x));
//*///End of F1 only block
//*// Block for both F1 and F2
    vec4 d = min(d1,d2); // F1 is now in d
    d2 = max(d1,d2); // Make sure we keep all candidates for F2
    d.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x
    d.xz = (d.x < d.z) ? d.xz : d.zx;
    d.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x
    d.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw
    d.y = min(d.y, d.z); // nor in d.z
    d.y = min(d.y, d.w); // nor in d.w
    d.y = min(d.y, d2.x); // F2 is now in d.y
    return sqrt(d.xy); // F1 and F2
//*/// End Of F1 and F2 block
}


void vertex() {
// Output:0

}

void fragment() {
// Input:4
	vec3 n_out4p0 = vec3(UV, 0.0);

// VectorDecompose:6
	float n_out6p0 = n_out4p0.x;
	float n_out6p1 = n_out4p0.y;
	float n_out6p2 = n_out4p0.z;

// Input:12
	float n_out12p0 = TIME;

// ScalarOp:13
	float n_in13p1 = 0.10000;
	float n_out13p0 = n_out12p0 * n_in13p1;

// VectorCompose:10
	vec3 n_out10p0 = vec3(n_out6p0, n_out6p1, n_out13p0);

// Scalar:5
	float n_out5p0 = 10.000000;

// Scalar:8
	float n_out8p0 = 1.000000;

// CelluarNoise3D_2x2x2:14
	vec3 n_out14p0;
	float n_out14p1;
	float n_out14p2;
	{
		
			
			n_out14p0 = vec3(cellular_noise_3d_2x2x2(n_out10p0 * vec3(n_out5p0), n_out8p0), 0.0);
			n_out14p1 = n_out14p0.x;n_out14p2 = n_out14p0.y;
			
	}

// ScalarOp:7
	float n_in7p1 = 0.50000;
	float n_out7p0 = step(n_out6p0, n_in7p1);

// ScalarMix:3
	float n_out3p0 = mix(n_out14p2, n_out14p1, n_out7p0);

// Output:0
	COLOR.rgb = vec3(n_out3p0);

}

void light() {
// Output:0

}
"
graph_offset = Vector2( -212, -38.25 )
mode = 1
flags/light_only = false
nodes/fragment/0/position = Vector2( 840, 60 )
nodes/fragment/3/node = SubResource( 80 )
nodes/fragment/3/position = Vector2( 660, 60 )
nodes/fragment/4/node = SubResource( 81 )
nodes/fragment/4/position = Vector2( -140, -20 )
nodes/fragment/5/node = SubResource( 82 )
nodes/fragment/5/position = Vector2( -160, 200 )
nodes/fragment/6/node = SubResource( 83 )
nodes/fragment/6/position = Vector2( 40, -60 )
nodes/fragment/7/node = SubResource( 84 )
nodes/fragment/7/position = Vector2( 440, -60 )
nodes/fragment/8/node = SubResource( 85 )
nodes/fragment/8/position = Vector2( -160, 280 )
nodes/fragment/10/node = SubResource( 89 )
nodes/fragment/10/position = Vector2( 140, 80 )
nodes/fragment/12/node = SubResource( 91 )
nodes/fragment/12/position = Vector2( -300, 80 )
nodes/fragment/13/node = SubResource( 92 )
nodes/fragment/13/position = Vector2( -80, 60 )
nodes/fragment/14/node = SubResource( 98 )
nodes/fragment/14/position = Vector2( 360, 140 )
nodes/fragment/connections = PoolIntArray( 4, 0, 6, 0, 6, 0, 7, 0, 7, 0, 3, 2, 3, 0, 0, 0, 6, 0, 10, 0, 6, 1, 10, 1, 12, 0, 13, 0, 13, 0, 10, 2, 14, 1, 3, 1, 14, 2, 3, 0, 10, 0, 14, 0, 5, 0, 14, 1, 8, 0, 14, 2 )

[sub_resource type="ShaderMaterial" id=97]
shader = SubResource( 96 )

[node name="Node2D" type="Node2D"]

[node name="Rotation" type="Sprite" parent="."]
material = SubResource( 7 )
position = Vector2( 57.2789, 57.2789 )
texture = ExtResource( 1 )

[node name="Label" type="Label" parent="Rotation"]
margin_left = -25.9443
margin_top = 38.4532
margin_right = 27.0557
margin_bottom = 52.4532
text = "Rotation"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Rotation 3D" type="Sprite" parent="."]
material = SubResource( 12 )
position = Vector2( 162.129, 55.3282 )
texture = ExtResource( 1 )

[node name="Label" type="Label" parent="Rotation 3D"]
margin_left = -25.9443
margin_top = 38.4532
margin_right = 27.0557
margin_bottom = 52.4532
text = "Rotation 3D"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 2D" type="ColorRect" parent="."]
material = SubResource( 17 )
margin_left = 284.839
margin_top = 34.1266
margin_right = 345.839
margin_bottom = 95.1266
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 2D"]
margin_left = -13.8511
margin_top = 63.2814
margin_right = 92.1489
margin_bottom = 77.2814
text = "Perlin noise (2D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 2D periodic" type="ColorRect" parent="."]
material = SubResource( 23 )
margin_left = 286.961
margin_top = 143.728
margin_right = 347.961
margin_bottom = 204.728
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 2D periodic"]
margin_left = -10.4644
margin_top = 65.1213
margin_right = 77.5356
margin_bottom = 96.1213
text = " Perlin noise
(2D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 3D" type="ColorRect" parent="."]
material = SubResource( 34 )
margin_left = 416.5
margin_top = 31.5
margin_right = 477.5
margin_bottom = 92.5
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 3D"]
margin_left = -14.3511
margin_top = 63.2814
margin_right = 91.6489
margin_bottom = 77.2814
text = "Perlin noise (3D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 3D periodic" type="ColorRect" parent="."]
material = SubResource( 43 )
margin_left = 422.157
margin_top = 143.223
margin_right = 483.157
margin_bottom = 204.223
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 3D periodic"]
margin_left = -14.3511
margin_top = 63.2814
margin_right = 91.6489
margin_bottom = 77.2814
text = " Perlin noise
(3D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 4D" type="ColorRect" parent="."]
material = SubResource( 52 )
margin_left = 545.865
margin_top = 32.3969
margin_right = 606.865
margin_bottom = 93.3969
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 4D"]
margin_left = -20.2103
margin_top = 62.7814
margin_right = 85.7897
margin_bottom = 76.7814
text = "Perlin noise (4D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Perlin Noise 4D periodic" type="ColorRect" parent="."]
material = SubResource( 62 )
margin_left = 550.108
margin_top = 144.12
margin_right = 611.108
margin_bottom = 205.12
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Perlin Noise 4D periodic"]
margin_left = -10.1005
margin_top = 63.7071
margin_right = 77.8995
margin_bottom = 94.7071
text = " Perlin noise
(4D, periodic)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Random noise" type="ColorRect" parent="."]
material = SubResource( 70 )
margin_left = 676.918
margin_top = 28.6563
margin_right = 737.918
margin_bottom = 89.6563
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Random noise"]
margin_left = 4.68323
margin_top = 66.0023
margin_right = 59.6832
margin_bottom = 97.0023
text = "Random
  noise"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 2D" type="ColorRect" parent="."]
material = SubResource( 79 )
margin_left = 801.277
margin_top = 28.8443
margin_right = 862.277
margin_bottom = 89.8443
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 2D"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
       (2D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 2D 2x2" type="ColorRect" parent="."]
material = SubResource( 88 )
margin_left = 911.52
margin_top = 30.0354
margin_right = 972.52
margin_bottom = 91.0354
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 2D 2x2"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
    (2D, 2x2)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 3D" type="ColorRect" parent="."]
material = SubResource( 94 )
margin_left = 800.958
margin_top = 139.476
margin_right = 861.958
margin_bottom = 200.476
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 3D"]
margin_left = -9.0
margin_top = 66.0
margin_right = 74.0
margin_bottom = 97.0
text = "Cellular noise
       (3D)"
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Cellular Noise 3D 2x2x2" type="ColorRect" parent="."]
material = SubResource( 97 )
margin_left = 912.797
margin_top = 141.998
margin_right = 973.797
margin_bottom = 202.998
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Label" type="Label" parent="Cellular Noise 3D 2x2x2"]
margin_left = -9.0
margin_top = 66.0
margin_right = 78.0
margin_bottom = 97.0
text = "Cellular noise
  (3D, 2x2x2)"
__meta__ = {
"_edit_use_anchors_": false
}
